
## 1. 引言

### 1.1 研究背景与意义

热传导（Heat Conduction）是热量传递的三种基本方式之一，广泛存在于航空航天热防护、电子器件散热管理、材料加工以及建筑节能等工程领域。在数学物理中，稳态热传导问题通常由椭圆型偏微分方程（Elliptic Partial Differential Equation, PDE）描述，最典型的形式为泊松方程（Poisson Equation）或拉普拉斯方程（Laplace Equation）。对于几何形状规则且边界条件简单的区域，我们可以通过分离变量法等解析手段获得精确解。然而，在实际工程应用中，往往面临复杂的几何边界、非均匀材料属性以及混合边界条件，解析解难以获得，数值模拟因此成为解决此类问题的核心手段。

本研究报告旨在响应数值分析课程大作业的要求，针对“问题三：均匀四边形网格上的二维稳态热传导问题”，构建一个从数学建模、离散化推导到程序实现及结果可视化的完整数值求解器。研究的核心在于采用**有限体积法（Finite Volume Method, FVM）**对控制方程进行离散。与有限差分法（FDM）相比，FVM 基于积分形式的守恒律，天然保证了物理量在离散控制体上的局部与全局守恒性，这使得它在处理热流、流体流动等守恒型问题时具有显著优势。

此外，本研究特别关注数值线性代数的实现效率。在离散化过程中生成的线性方程组具有大型、稀疏的特征。为了高效求解该系统，本研究引入 C++ 高性能线性代数库 **Eigen**。通过深入分析 Eigen 的稀疏矩阵存储格式（Sparse Matrix Storage Formats）与求解器算法（如 SimplicialLLT, SparseLU），本报告将探讨如何优化内存占用与计算速度，并据此设计和更新 `include/NumCpp.h` 头文件，以实现数值计算模块的封装与复用。

### 1.2 问题定义与物理模型

根据大作业“问题三”的描述，考察对象为定义在单位正方形区域 $\Omega = [0,1] \times [0,1]$ 内的二维稳态导热介质。假设材料各向同性且导热系数 $k$ 为常数。

控制方程（Governing Equation）：

稳态热传导方程为泊松方程形式：

$$-\nabla \cdot (k \nabla T) = q \quad \text{in } \Omega$$

其中，$T(x,y)$ 表示温度场，$q$ 为单位体积内的恒定热源生成率（Heat Generation Rate）。对于纯导热问题（无内热源），$q=0$，方程退化为拉普拉斯方程 $-\nabla^2 T = 0$。

**计算域与网格（Computational Domain & Mesh）：**

- **区域**：$\Omega = \{(x,y) | 0 \le x \le 1, 0 \le y \le 1\}$。
    
- **网格划分**：采用 $50 \times 50$ 的均匀结构化四边形网格（Structured Quadrilateral Grid）。
    
- **离散方式**：中心式离散（Cell-Centered Scheme），即温度未知量定义在每个控制体积（Control Volume, CV）的几何中心。
    

边界条件（Boundary Conditions, BCs）：

为了封闭方程组，在区域边界 $\Gamma = \partial \Omega$ 上施加如下混合边界条件：

- **西边界**（Left, $\Gamma_W$）： Dirichlet 边界条件，$T(0, y) = 100$。
    
- **东边界**（Right, $\Gamma_E$）： Dirichlet 边界条件，$T(1, y) = 0$。
    
- **南边界**（Bottom, $\Gamma_S$）： Neumann 边界条件（绝热），$-k \frac{\partial T}{\partial y}|_{y=0} = 0$。
    
- **北边界**（Top, $\Gamma_N$）： Neumann 边界条件（绝热），$-k \frac{\partial T}{\partial y}|_{y=1} = 0$。
    

该物理模型描述了一个经典的二维热传导场景：热量从高温左壁流入，通过介质向低温右壁传导，由于上下壁面绝热，热流线主要沿水平方向分布。

---

## 2. 有限体积法数学理论与离散化

有限体积法的核心在于将计算域划分为一系列互不重叠的控制体积，并对守恒型控制方程在每个控制体积上积分。通过高斯散度定理，将体积分转化为面积分，从而建立通量平衡方程。

### 2.1 积分守恒方程的推导

对于任意控制体积 $V_P$，控制方程的积分形式为：

$$\int_{V_P} -\nabla \cdot (k \nabla T) \, dV = \int_{V_P} q \, dV$$

应用高斯散度定理（Gauss's Divergence Theorem），左边的体积分项转化为边界表面 $S_P$ 上的通量积分：

$$-\oint_{S_P} (k \nabla T) \cdot \mathbf{n} \, dS = \int_{V_P} q \, dV$$

其中，$\mathbf{n}$ 是指向控制体积外部的单位法向量。

在二维笛卡尔网格中，控制体积 $V_P$ 为矩形单元，其边界 $S_P$ 由东（East, e）、西（West, w）、北（North, n）、南（South, s）四个面组成。因此，面积分可以分解为四个面的积分之和：

$$-\left( \int_{e} \mathbf{J} \cdot \mathbf{n}_e \, dS + \int_{w} \mathbf{J} \cdot \mathbf{n}_w \, dS + \int_{n} \mathbf{J} \cdot \mathbf{n}_n \, dS + \int_{s} \mathbf{J} \cdot \mathbf{n}_s \, dS \right) = \bar{q} \Delta V$$

这里引入热通量密度向量 $\mathbf{J} = k \nabla T$。若定义流出控制体为正方向，则上述方程描述了“流入的热量 + 生成的热量 = 流出的热量”。

### 2.2 空间离散与通量近似

在 $50 \times 50$ 的均匀网格中，网格步长为 $\Delta x = \Delta y = h = 0.02$。由于采用体心格式（Cell-Centered），标量 $T$ 存储在单元中心 $P$，而通量计算发生在单元界面（Face）上。

我们需要近似界面处的法向梯度 $\nabla T \cdot \mathbf{n}$。对于均匀正交网格，连接相邻节点 $P$ 和 $E$ 的直线与界面 $e$ 垂直。

东面（East Face, e）的扩散通量：

界面 $e$ 的面积为 $A_e = \Delta y$。法向导数近似为：

$$\left( \frac{\partial T}{\partial x} \right)_e \approx \frac{T_E - T_P}{\Delta x}$$

因此，通过东面的扩散通量 $F_e$ 为：

$$F_e \approx k \frac{\Delta y}{\Delta x} (T_E - T_P)$$

离散代数方程的通用形式：

将所有面的通量代入守恒方程，并整理同类项，可得五点差分格式的线性代数方程：

$$a_P T_P = a_E T_E + a_W T_W + a_N T_N + a_S T_S + S_u$$

其中系数 $a_{nb}$ 代表了邻居节点对中心节点的影响权重：

- $a_E = a_W = \frac{k \Delta y}{\Delta x}$
    
- $a_N = a_S = \frac{k \Delta x}{\Delta y}$
    
- $a_P = a_E + a_W + a_N + a_S$
    
- $S_u = q \Delta x \Delta y$
    

### 2.3 边界条件的详细数值处理

在体心 FVM 格式中，边界节点与最近的内部节点（体心）之间的距离是网格步长的一半（$h/2$）。

#### 2.3.1 Dirichlet 边界处理（左右边界）

在左边界（West, $i=0$），已知边界温度 $T_{bc} = 100$。

节点 $P$ 到边界面 $w$ 的距离 $\delta x_{Pw} = \Delta x / 2$。通量近似为：

$$F_w \approx - \frac{2k \Delta y}{\Delta x} (T_P - 100)$$

修正策略：

1. 令 $a_W = 0$。
    
2. 修正中心系数：$a_P \leftarrow a_P + \frac{2k \Delta y}{\Delta x}$。
    
3. 修正源项：$S_u \leftarrow S_u + \frac{2k \Delta y}{\Delta x} \cdot 100$。
    

#### 2.3.2 Neumann 边界处理（上下边界）

在下边界（South, $j=0$），给定绝热条件 $\frac{\partial T}{\partial n} = 0$，即 $F_s = 0$。

修正策略：

1. 令 $a_S = 0$。
    
2. 不需要对 $a_P$ 或 $S_u$ 做额外修正。
    

### 2.4 全局线性系统的构建

将所有 $N = 2500$ 个方程联立，形成系统 $Ax=b$。

- **未知量向量 $\mathbf{x}$**：一维映射 $I = j \times N_x + i$。
    
- **系数矩阵 $A$**：稀疏矩阵，五对角结构。具有**稀疏性**和**对称正定性（SPD）**。
    

---

## 3. 基于 Eigen 的数值求解策略

### 3.1 稀疏矩阵的存储与组装

**最佳实践：三元组列表（Triplet List）**

1. 创建 `std::vector<Eigen::Triplet<double>>`。
    
2. 预分配内存：`triplets.reserve(N * 5)`。
    
3. 遍历网格填充三元组。
    
4. 调用 `SparseMatrix::setFromTriplets()` 一次性构建压缩存储结构。
    

### 3.2 求解器的选择与分析

|**求解器类 (Eigen Class)**|**算法原理**|**适用矩阵类型**|**本问题适用性分析**|
|---|---|---|---|
|**SimplicialLLT**|稀疏 Cholesky 分解|对称正定 (SPD)|**最佳选择**。速度最快，内存占用低。|
|**SimplicialLDLT**|稀疏 LDLT 分解|对称半正定|可选。稳定性高，但本问题 LLT 足够。|
|**SparseLU**|稀疏 LU 分解|一般方阵|可用，但非最优（浪费算力处理对称性）。|
|**ConjugateGradient**|共轭梯度法 (CG)|SPD|大规模（如 $1000^2$）首选，本规模直接法更快。|

---

## 4. 程序架构与 include/NumCpp.h 设计

### 4.1 NumCpp.h 设计理念

- **类型别名**：简化 `Eigen` 冗长类型。
    
- **求解器封装**：提供统一的 `solve` 接口。
    
- **数据 IO**：支持导出 CSV 格式。
    

### 4.2 核心代码实现 (NumCpp.h)

C++

```
/**
 * @file NumCpp.h
 * @brief 基于 Eigen 库的数值分析工具集
 */
#ifndef NUMCPP_H
#define NUMCPP_H

#include <Eigen/Sparse>
#include <Eigen/Dense>
#include <Eigen/IterativeLinearSolvers>
#include <Eigen/SparseCholesky>
#include <Eigen/SparseLU>
#include <vector>
#include <iostream>
#include <fstream>
#include <string>

namespace NumCpp {
    using SpMat = Eigen::SparseMatrix<double>;
    using Triplet = Eigen::Triplet<double>;
    using Vector = Eigen::VectorXd;
    using Matrix = Eigen::MatrixXd;

    enum class SolverType { SimplicialLLT, SparseLU, BiCGSTAB, ConjugateGradient };

    class LinearSolver {
    public:
        static bool solve(const SpMat& A, const Vector& b, Vector& x, SolverType type = SolverType::SimplicialLLT) {
            if (type == SolverType::SimplicialLLT) {
                Eigen::SimplicialLLT<SpMat> solver(A);
                x = solver.solve(b);
                return (solver.info() == Eigen::Success);
            } 
            else if (type == SolverType::SparseLU) {
                Eigen::SparseLU<SpMat> solver;
                solver.compute(A);
                x = solver.solve(b);
                return (solver.info() == Eigen::Success);
            }
            // 其他迭代求解器逻辑...
            return false;
        }
    };

    inline void saveToCSV(const std::string& filename, const Matrix& matrix) {
        const static Eigen::IOFormat CSVFormat(Eigen::StreamPrecision, Eigen::DontAlignCols, ", ", "\n");
        std::ofstream file(filename);
        if (file.is_open()) {
            file << matrix.format(CSVFormat);
            file.close();
        }
    }
}
#endif
```

### 4.3 主程序 main.cpp 实现

C++

```
#include "include/NumCpp.h"

int main() {
    const int Nx = 50, Ny = 50;
    double dx = 1.0/Nx, dy = 1.0/Ny, k = 1.0;
    int N_dof = Nx * Ny;

    std::vector<NumCpp::Triplet> triplets;
    NumCpp::Vector b = NumCpp::Vector::Zero(N_dof);

    double a_e = k * dy / dx, a_w = k * dy / dx;
    double a_n = k * dx / dy, a_s = k * dx / dy;

    for (int j = 0; j < Ny; ++j) {
        for (int i = 0; i < Nx; ++i) {
            int P = j * Nx + i;
            double a_P = 0.0;

            if (i == 0) { a_P += 2*a_w; b(P) += 2*a_w*100.0; } 
            else { triplets.emplace_back(P, P-1, -a_w); a_P += a_w; }

            if (i == Nx-1) { a_P += 2*a_e; b(P) += 2*a_e*0.0; }
            else { triplets.emplace_back(P, P+1, -a_e); a_P += a_e; }

            if (j > 0) { triplets.emplace_back(P, P-Nx, -a_s); a_P += a_s; }
            if (j < Ny-1) { triplets.emplace_back(P, P+Nx, -a_n); a_P += a_n; }

            triplets.emplace_back(P, P, a_P);
        }
    }

    NumCpp::SpMat A(N_dof, N_dof);
    A.setFromTriplets(triplets.begin(), triplets.end());
    NumCpp::Vector x(N_dof);
    NumCpp::LinearSolver::solve(A, b, x);

    NumCpp::Matrix T_field(Ny, Nx);
    for(int j=0; j<Ny; ++j) for(int i=0; i<Nx; ++i) T_field(j,i) = x(j*Nx+i);
    NumCpp::saveToCSV("temperature_field.csv", T_field);
    return 0;
}
```

---

## 5. 结果可视化与分析

### 5.1 可视化脚本 (Python)

Python

```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

def plot_temperature_field():
    data = pd.read_csv("temperature_field.csv", header=None).values
    Ny, Nx = data.shape
    x = np.linspace(1.0/(2*Nx), 1.0-1.0/(2*Nx), Nx)
    y = np.linspace(1.0/(2*Ny), 1.0-1.0/(2*Ny), Ny)
    X, Y = np.meshgrid(x, y)

    plt.figure(figsize=(10, 8))
    cp = plt.contourf(X, Y, data, 50, cmap='inferno')
    plt.colorbar(cp).set_label('Temperature ($^\circ$C)')
    cs = plt.contour(X, Y, data, 10, colors='white', alpha=0.5)
    plt.clabel(cs, inline=True, fontsize=8)
    plt.title('FVM Steady State Temperature Distribution')
    plt.show()
```

### 5.2 结果物理验证与分析

- **左高右低梯度**：符合热量从高温 (100) 向低温 (0) 传导。
    
- **绝热边界正交性**：等温线与 $y=0$ 和 $y=1$ 边界垂直，验证了 Neumann 条件。
    
- **一维主导特性**：$T(x,y) \approx 100(1-x)$，证明了求解器的精度。
    

---

## 6. 结论

本研究报告通过理论推导、C++ 高性能编程及 Python 可视化，成功实现了二维稳态热传导问题的数值模拟。

1. **理论层面**：FVM 有效保证了局部守恒性。
    
2. **实现层面**：利用 Eigen 稀疏矩阵模块与 SimplicialLLT 求解器，实现了极高的计算效率。
    
3. **工程层面**：模块化的 `NumCpp` 接口为复杂热传导问题提供了可扩展的开发框架。
    
