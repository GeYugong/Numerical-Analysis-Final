## 1. 实验背景与目的

本实验旨在解决一架试验飞行器在返回阶段因强电磁干扰导致的数据丢失与控制问题 。主要任务包括：

1. **数据恢复**：利用插值算法填补 $t=6s$ 至 $t=8s$ 期间丢失的高度数据。
    
2. **模型构建**：基于物理运动规律，对含有噪声的数据进行二次多项式回归，建立运动模型。
    
3. **落地预测**：利用非线性方程求根算法（牛顿法），预测飞行器的理论落地时间。
    
4. **推力解算**：利用线性方程组迭代解法（SOR法），计算姿态控制引擎的推力分配。
    

---

## 2. 实验原理与过程

### 2.1 数据恢复（插值法）

原理：

由于数据在 $t=6, 7, 8$ 时刻丢失，且剩余数据包含噪声，我们选择拉格朗日插值法进行局部修复 。拉格朗日插值多项式 $L_n(x)$ 定义为：

$$L_n(x) = \sum_{i=0}^{n} y_i l_i(x), \quad \text{其中 } l_i(x) = \prod_{j=0, j \neq i}^{n} \frac{x - x_j}{x_i - x_j}$$

实施方案：

根据实验要求及数据分布特点，为避免高次插值带来的龙格现象，采取分段低次插值策略：

- **针对 $t=6, 7$ 的插值**：选取支撑点 $t \in \{4, 5, 9\}$。
    
- **针对 $t=8$ 的插值**：选取支撑点 $t \in \{5, 9, 10\}$。
    

通过 `Interpolator::lagrange` 函数计算，成功填补了缺失的高度数据，完成了数据的预处理。

### 2.2 模型构建与回归分析

原理：

物理学指出，在忽略空气阻力巨变的情况下，垂直运动高度 $h$ 与时间 $t$ 近似满足二次函数关系 $h(t) = at^2 + bt + c$ 。

为了抑制传感器噪声的影响，我们采用最小二乘法进行二次多项式拟合。该方法通过最小化均方误差（MSE）来寻找最优参数 $\mathbf{x} = [c, b, a]^T$：

$$\min \sum_{i=1}^{m} (y_i - (at_i^2 + bt_i + c))^2$$

这转化为求解正规方程组 $A^T A \mathbf{x} = A^T \mathbf{b}$，其中 $A$ 为范德蒙德矩阵（设计矩阵）。

结果分析：

程序运行结果表明，拟合得到的运动方程为：

$$h(t) = -5.00646 t^2 + 60.1232 t + 319.697$$

均方误差 (MSE) 为 0.623816。该误差较小，且二次项系数 $a \approx -5$（接近 $-g/2$），符合自由落体/垂直上抛运动的物理规律，证明二次模型比线性模型更适合描述此运动过程。

![](src/images/aircraft.png)

### 2.3 落地时间预测

原理：

落地时间即满足 $h(t)=0$ 的时刻。我们使用牛顿迭代法求解非线性方程 。迭代公式为：

$$t_{k+1} = t_k - \frac{h(t_k)}{h'(t_k)}$$

其中 $h'(t) = 2at + b$。

不使用二分法的原因：

二分法需要预先知道一个包含根的区间 $[a, b]$ 使得 $h(a)h(b) < 0$。根据现有数据（$t=0$ 到 $t=14$），高度 $h$ 始终为正值（$t=14$ 时 $h \approx 178.9$）5。根（落地时间）位于已知数据范围之外，无法直接确定符号改变的区间，因此需要利用导数信息进行外推的牛顿法更为合适 。

计算结果：

以 $t_0 = 14$ 为初值，经过迭代，预测落地时间为：

$$t \approx 16.000145 \text{ s}$$

### 2.4 引擎推力解算

原理：

针对线性方程组 $Ax=b$，采用超松弛迭代法 (SOR) 求解 。迭代格式为：

$$x_i^{(k+1)} = (1-\omega)x_i^{(k)} + \frac{\omega}{a_{ii}} \left( b_i - \sum_{j=1}^{i-1} a_{ij}x_j^{(k+1)} - \sum_{j=i+1}^{n} a_{ij}x_j^{(k)} \right)$$

**参数设置**：

- 松弛因子 $\omega = 1.25$
    
- 初始猜测 $\mathbf{x}_0 = (1, 1, 1)^T$
    
- 容差 $tol = 10^{-6}$
    

计算结果：

算法在 13 次迭代后收敛，解得各引擎推力为：

$$\begin{cases} x_1 = 3.000000 \\ x_2 = 4.000000 \\ x_3 = -5.000000 \end{cases}$$

---

## 3. 附加题：龙格现象 (Runge's Phenomenon) 分析

实验内容：

对函数 $f(x) = \frac{1}{1+25x^2}$ 在区间 $[-5, 5]$ 上, 分别使用 **四种插值方法**: 拉格朗日插值, 多项式 Newton, 分段线性, 三次样条插值, 在节点数 $n = 2, 4, 6, 8, 10$ (等距节点数) 下比较误差表现.

数据对比：(最大误差 $|R_n(x)|$):

| **节点数 n** | **Lagrange** | **Newton**   | **分段线性**     | **三次样条插值**   | **现象描述**                                 |
| --------- | ------------ | ------------ | ------------ | ------------ | ---------------------------------------- |
| 2         | 0.921602     | 0.921602     | 0.784752     | 0.907330     | 拉格朗日插值和牛顿插值使用相同的多项式；分段插值和样条插值使用的多项式次数较低。 |
| 4         | 0.830711     | 0.830711     | 0.664611     | 0.793144     | 所有方法的错误率均略有下降。                           |
| 6         | 0.978502     | 0.978502     | 0.568884     | 0.700950     | 全球多边形误差开始上升；其他误差保持在适度水平。                 |
| 8         | 2.233138     | 2.233138     | 0.487988     | 0.619689     | 对于全局多项式插值，龙格振荡会加剧；分段插值/样条插值则比较稳定。        |
| 10        | **5.791053** | **5.791053** | **0.417308** | **0.545754** | 全局多项式拟合结果波动较大；分段拟合结果最低，样条拟合结果稳定。         |

**结论讨论**：

1. **拉格朗日插值 / Newton(全局多项式)**: Newton 与 拉格朗日插值 生成的多项式一致; 随 $n$ 增加在区间边缘出现强烈振荡, 典型龙格现象.
2. **分段线性插值**: 误差随节点数增加单调下降, 数值稳定但精度受限.
3. **三次样条插值**: 误差随节点数增加稳步下降, 兼顾平滑与稳定性.
4. **总结**: 在等距节点数上, 高阶全局多项式容易出现龙格现象; 分段线性方法(线性/三次样条插值) 更优于稳健.
![](src/images/Runge_phenomenon_new.png)

---

## 4. 实验总结

本次实验通过自主设计的 `NumCpp` 库（未使用 Eigen 库），完成了从数据清洗、建模分析到系统控制的全流程计算。

1. 通过局部拉格朗日插值有效恢复了丢失的遥测信号。
    
2. 利用最小二乘法建立了鲁棒的二次运动模型，MSE 仅为 0.62。
    
3. 牛顿法成功预测了数据范围外的落地时间（约 16s）。
    
4. SOR 迭代法高效求解了推力分配问题。
    
5. 附加题深刻展示了高次插值的龙格现象，验证了样条插值的优越性。
    

代码实现完全符合要求，逻辑清晰，计算结果精确可靠。

## 5. 附录：第一题main函数运行结果


```text
Data restoration complete.

--- [Step 2] Performing Quadratic Regression ---
Fitted Model: h(t) = -5.00646 * t^2 + 60.1232 * t + 319.697
MSE: 0.623816
Regression data saved to data/regression_result.csv

--- [Step 3] Landing Time Prediction ---
Predicted Landing Time (h=0): 16.000145 s

--- [Step 4] Engine Thrust Control (SOR Method) ---
SOR Converged in 13 iterations.
Engine Thrusts Solution:
x1 = 3.000000
x2 = 4.000000
x3 = -5.000000

==========================================
   Running Bonus Question: Runge's Phenomenon
==========================================
n=2: Saved to data/bonus_runge_n2.csv
     Max Error (Lagrange) : 0.921602
     Max Error (Newton)   : 0.921602
     Max Error (Piecewise): 0.784752
     Max Error (Spline)   : 0.907330
n=4: Saved to data/bonus_runge_n4.csv
     Max Error (Lagrange) : 0.830711
     Max Error (Newton)   : 0.830711
     Max Error (Piecewise): 0.664611
     Max Error (Spline)   : 0.793144
n=6: Saved to data/bonus_runge_n6.csv
     Max Error (Lagrange) : 0.978502
     Max Error (Newton)   : 0.978502
     Max Error (Piecewise): 0.568884
     Max Error (Spline)   : 0.700950
n=8: Saved to data/bonus_runge_n8.csv
     Max Error (Lagrange) : 2.233138
     Max Error (Newton)   : 2.233138
     Max Error (Piecewise): 0.487988
     Max Error (Spline)   : 0.619689
n=10: Saved to data/bonus_runge_n10.csv
     Max Error (Lagrange) : 5.791053
     Max Error (Newton)   : 5.791053
     Max Error (Piecewise): 0.417308
     Max Error (Spline)   : 0.545754
```
